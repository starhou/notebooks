# 进程和线程


## 线程的实现
* 在用户空间中实现线程
    优点
    1. 进行类似于线程切换这样的操作至少比陷入内核要快一个数量级。
    2. 允许每个进程有自己定制的调度算法。
    缺点
    1. 阻塞系统不容易使用
    2. 缺页中断问题
* 在内核中实现线程


## 进程间通信 (Inter Process Communication, IPC)
### 三个问题，
1. 如何把信息传递给另一个？
2. 确保两个或更多的进程在关键活动中不会出现交叉
3. 正确的顺序

### 互斥避免竞争

1. 任何两个进程不能同时处于临界区
2. 不应对CPU的速度和数量做出任何假设
3. 临界区外运行的进程不得阻塞其他进程
4. 不得使进程无限期等待进入临界区


#### 实现忙等待的互斥

1. **屏蔽中断** 不好，特别是对多核CPU，很难完全屏蔽中断，而且将屏蔽中断权力交给用户是比较愚蠢的行为。
2. **锁变量** 维护一个锁变量，当一个进程进去临界区后，就上锁，关门。这样还是有问题，在进程进入临界区到关上门之间，如果中断切换进程，也会出问题。
3. **严格轮换法**  比如说两个进程，如下面代码，用一个变量turn来表示其状态，这种思路叫**自旋锁**，令牌法。这种思路在两个进程速度不一致情况下并不好，比如进程1进入临界区后很快出来了，这时候turn=1，而进程2还在忙自己临界区外的工作，没有进入临界区，而进程1速度飞起，又把外面工作做完想进入临界区，但并不能，因为进程2太慢了。这就有可能出现临界区没人还进不去，就很气。这违反条件3.
```C
    /*进程1*/
    while(1)
    {
        while(turn != 0);  /*循环*/
        critical_region();
        turn = 1;
        noncritical_region();
    }

    /*进程2*/
    while(1)
    {
        while(turn != 1);  /*循环*/
        critical_region();
        turn = 0;
        noncritical_region();
    }
```
4. **Peterson解法** 如果说共享锁是“锁法”，严格轮换法是“令牌法”，这个方法可以叫“坑法”，这个方法也有一个令牌变量turn, 每个进入临界区的进程都会说自己进入了临界区，然后去抢令牌。有个坑是，如果这哥们抢到了令牌，然后发现别人先宣布了。那么它就会while等待。这迫使进程之间养成谦让的好习惯。这个方法比令牌法好的是，令牌法有可能出现临界区没人还进不去的愚蠢情况。这种方法只要没人，肯定能进。

```C
#define FALSE 0
#define TRUE  1
#define N     2 /*进程数量*/

int turn;
int interested[N];

void enter_region(int process)
{
    int other;

    other = 1-process;
    interested[process] = TRUE;
    turn = process;
    while(turn == process && interested[other] == TRUE);
}

void leave_egion(int process)
{
    interested[process] = FALSE;
}
```
5. **TSL指令**
硬件实现。
TSL RX, LOCK
这将会锁住CPU总线，来禁止其他CPU访问。不同于屏蔽中断，只要只有一根总线，其他CPU来了也不行，因为你只能屏蔽自己CPU的中断，无法全部屏蔽。