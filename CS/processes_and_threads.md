# 进程和线程


## 线程的实现
* 在用户空间中实现线程
    优点
    1. 进行类似于线程切换这样的操作至少比陷入内核要快一个数量级。
    2. 允许每个进程有自己定制的调度算法。
    缺点
    1. 阻塞系统不容易使用
    2. 缺页中断问题
* 在内核中实现线程


## 进程间通信 (Inter Process Communication, IPC)
### 三个问题，
1. 如何把信息传递给另一个？
2. 确保两个或更多的进程在关键活动中不会出现交叉
3. 正确的顺序

### 互斥避免竞争

1. 任何两个进程不能同时处于临界区
2. 不应对CPU的速度和数量做出任何假设
3. 临界区外运行的进程不得阻塞其他进程
4. 不得使进程无限期等待进入临界区


#### 实现忙等待的互斥

1. **屏蔽中断** 不好，特别是对多核CPU，很难完全屏蔽中断，而且将屏蔽中断权力交给用户是比较愚蠢的行为。
2. **锁变量** 维护一个锁变量，当一个进程进去临界区后，就上锁，关门。这样还是有问题，在进程进入临界区到关上门之间，如果中断切换进程，也会出问题。
3. **严格轮换法**  比如说两个进程，如下面代码，用一个变量turn来表示其状态，这种思路叫**自旋锁**，令牌法。这种思路在两个进程速度不一致情况下并不好，比如进程1进入临界区后很快出来了，这时候turn=1，而进程2还在忙自己临界区外的工作，没有进入临界区，而进程1速度飞起，又把外面工作做完想进入临界区，但并不能，因为进程2太慢了。这就有可能出现临界区没人还进不去，就很气。这违反条件3.
```C
    /*进程1*/
    while(1)
    {
        while(turn != 0);  /*循环*/
        critical_region();
        turn = 1;
        noncritical_region();
    }

    /*进程2*/
    while(1)
    {
        while(turn != 1);  /*循环*/
        critical_region();
        turn = 0;
        noncritical_region();
    }
```
4. **Peterson解法** 如果说共享锁是“锁法”，严格轮换法是“令牌法”，这个方法可以叫“坑法”，这个方法也有一个令牌变量turn, 每个进入临界区的进程都会说自己进入了临界区，然后去抢令牌。有个坑是，如果这哥们抢到了令牌，然后发现别人先宣布了。那么它就会while等待。这迫使进程之间养成谦让的好习惯。这个方法比令牌法好的是，令牌法有可能出现临界区没人还进不去的愚蠢情况。这种方法只要没人，肯定能进。

```C
#define FALSE 0
#define TRUE  1
#define N     2 /*进程数量*/

int turn;
int interested[N];

void enter_region(int process)
{
    int other;

    other = 1-process;
    interested[process] = TRUE;
    turn = process;
    while(turn == process && interested[other] == TRUE);
}

void leave_egion(int process)
{
    interested[process] = FALSE;
}
```
5. **TSL指令**
硬件实现。
TSL RX, LOCK
这将会锁住CPU总线，来禁止其他CPU访问。不同于屏蔽中断，只要只有一根总线，其他CPU来了也不行，因为你只能屏蔽自己CPU的中断，无法全部屏蔽。

#### 睡眠与唤醒

##### 生产者与消费者问题

问题是两个进程读写一个buffer，一个a进程只读，一个b进程只写。当缓冲区为空的时候。假设此时cpu运行读进程，但是buffer为空，所以必须等写进程写数据后再读，如果忙等待的话，它占着CPU，写进程也没法写，就死锁了。所以在**读进程发现buffer为空或者写进程发现buffer满了，应该先睡眠，等另一个进程执行完后再叫醒它，而不是忙等待。**

什么是睡眠？
书上没有说清楚，我理解的是这样的。首先，睡眠是一个抽象的概念，既可以通过内核态实现，比如说停止切换到该进程，也可以用户态，比如忙等待。如果一个进程睡眠了，那么很容易想到的是，该进程中所有的状态变量都会失效。但其进程独有的定时器、文件和内存不变。只是不工作了。当睡着的进程被叫醒的时候，它会更新自己的状态变量，比如说，buffer里元素个数。睡之前buffer里面没有元素，睡醒后可能就有了。

根据上述对睡眠的理解，就衍生出来两个问题，
1. 睡眠指令的丢失。这就相当于没加锁，会出现竞争。
2. 叫醒指令的丢失。每个进程会有自己的缓存，他们不会每次都去读共享锁变量。只有当收到叫醒指令时候，会去读共享锁变量，如果叫醒指令丢失，根据软件设计的lazy原则，进程会选择读自己的缓存，这时虽然共享锁变量更新了，让它运行，但它不知道，它依旧按照自己的想法，继续睡。最后的结果就是内存爆掉，或者读不存在的变量，或者死锁。

#### 信号量

通过分析，该问题的关键就是每次要用到一个关键的锁变量的时候，一定要保证这是最新的产品。

原子操作：检测数值、修改变量值、睡眠三者之间不可分隔。

信号量是一个数，非负整数。可以被多个进程共享。
down: 如果信号量大于0，则减一；如果等于0，睡之~ 
up: 信号量加一。所有进程都在睡。也包括自己，比如说自己先down一波，然后自己睡了。那么就会按照某种准则选取一个进程运行。

#### 互斥量

就是锁啊，为啥又说一边，还起个新名字，不懂。

基本思路，一个进程要访问共享数据结构，看上锁没，上锁了，阻塞该进程，也可以睡之，直到另一个进程叫醒，或者下次轮到自己。


#### 锁，令牌的本质

不管啥方法，都要有一个锁，或者叫状态变量。它是啥？其实他就是共享变量啊，从物理特性上来说和共享的数据结构没啥区别。其实我们每次都能读共享变量，只不过读到第一个，发现上锁了，也就是第一个变量是某个值，一般为0。然后我们就不读了，全凭自觉，哈哈。

具体实现：
1. 内核中保存，只能系统调用来实现。
2. 使进程共享部分地址。这种方法模糊了进程和线程的区别。

##### 快速用户区互斥量flutex

其实，从数据结构上来说，就是锁加一个队列，多个进程冲突的问题，本质上就是一个多对一问题。在数据结构中，栈和队列都能很好的解决这个问题。但一般说栈和队列自带一种顺序，先入先出或先入后出。这里可以做成那种蓄水池的概念，每次按某种准则捞一个上来。 

##### pthread的互斥量

pthread中有条件变量，满足条件睡眠，或者说满足条件唤醒。

##### 管程

一种语言实现的特性。管程的一个重要的特性，任一时刻管程中只能有一个活跃进程。就是别人帮你搞好，用就完了。


##### 消息传递

如果一个分布式系统具有多个CPU，并且每个CPU拥有自己的内存，它们通过一个局域网相连，之前的方法会失效。

这就用到消息，主要就是send和receive。

##### 屏障
阶段化，可用于一组进程的同步。

##### 无锁

最好锁就是没有锁，具体来说就是只要保证正常使用。